{
  "version": 3,
  "sources": ["../../../../../../node_modules/idb/build/index.js"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(this.request);\n    };\n  }\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking,\n  terminated\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event.newVersion, event));\n  }\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) {\n      db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event));\n  }\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n  get(target, prop) {\n    if (!advanceMethodProps.includes(prop)) return target[prop];\n    let cachedFunc = methodMap[prop];\n    if (!cachedFunc) {\n      cachedFunc = methodMap[prop] = function (...args) {\n        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n      };\n    }\n    return cachedFunc;\n  }\n};\nasync function* iterate(...args) {\n  // tslint:disable-next-line:no-this-assignment\n  let cursor = this;\n  if (!(cursor instanceof IDBCursor)) {\n    cursor = await cursor.openCursor(...args);\n  }\n  if (!cursor) return;\n  cursor = cursor;\n  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n  // Map this double-proxy back to the original, so other cursor methods work.\n  reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n  while (cursor) {\n    yield proxiedCursor;\n    // If one of the advancing methods was not called, call continue().\n    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n    advanceResults.delete(proxiedCursor);\n  }\n}\nfunction isIteratorProp(target, prop) {\n  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore]);\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get(target, prop, receiver) {\n    if (isIteratorProp(target, prop)) return iterate;\n    return oldTraps.get(target, prop, receiver);\n  },\n  has(target, prop) {\n    return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n  }\n}));\nexport { deleteDB, openDB, unwrap, wrap };"],
  "mappings": "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",
  "names": ["target"]
}
