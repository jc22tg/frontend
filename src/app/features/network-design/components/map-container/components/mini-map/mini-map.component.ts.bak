import { Component, OnInit, AfterViewInit, OnDestroy, Input, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild, ElementRef, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { NetworkElement } from '../../../../../../shared/types/network.types';
import { LoggerService } from '../../../../../../core/services/logger.service';

/**
 * Interfaz para datos del viewport en el minimapa
 */
export interface MiniMapViewport {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}

/**
 * Constantes utilizadas en el componente
 */
const CONSTANTS = {
  MINIMAP: {
    DEFAULT_WIDTH: 200,
    DEFAULT_HEIGHT: 150,
    ELEMENT_RADIUS: 2,
    VIEWPORT_STROKE: '#ff4081',
    VIEWPORT_FILL: 'rgba(255, 64, 129, 0.1)',
    ELEMENT_COLOR: '#2196f3',
    ELEMENT_STROKE: '#fff',
    BORDER_COLOR: '#ddd',
    BORDER_COLOR_DARK: '#555'
  }
};

/**
 * Componente para el minimapa
 * 
 * Este componente muestra una vista en miniatura de todo el mapa de red,
 * permitiendo ubicarse rápidamente y navegar a diferentes áreas.
 */
@Component({
  selector: 'app-mini-map',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="mini-map-container" 
      [class.dark-mode]="isDarkMode"
      [class.hidden]="!isVisible"
      [style.width.px]="width"
      [style.height.px]="height">
      <div #miniMapCanvas class="mini-map-canvas"></div>
      <div class="mini-map-controls">
        <button class="zoom-control" (click)="zoomIn()">+</button>
        <button class="zoom-control" (click)="zoomOut()">-</button>
      </div>
    </div>
  `,
  styles: [`
    .mini-map-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border-color, #ddd);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      z-index: 5;
      transition: opacity 0.3s ease;
    }
    
    .mini-map-container.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .mini-map-container.dark-mode {
      background-color: rgba(33, 33, 33, 0.9);
      --border-color: #555;
      --element-color: #4fc3f7;
      --viewport-stroke: #ff80ab;
      --text-color: #fff;
    }
    
    .mini-map-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .mini-map-controls {
      position: absolute;
      bottom: 5px;
      right: 5px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .zoom-control {
      width: 18px;
      height: 18px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(255, 255, 255, 0.7);
      border: 1px solid #ddd;
      border-radius: 2px;
      font-size: 12px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .zoom-control:hover {
      background-color: rgba(255, 255, 255, 0.9);
    }
    
    .dark-mode .zoom-control {
      background-color: rgba(66, 66, 66, 0.7);
      border-color: #555;
      color: white;
    }
    
    .dark-mode .zoom-control:hover {
      background-color: rgba(66, 66, 66, 0.9);
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class MiniMapComponent implements OnInit, AfterViewInit, OnDestroy {
  @ViewChild('miniMapCanvas', { static: true }) miniMapCanvasEl!: ElementRef;
  
  @Input() set elements(value: NetworkElement[]) {
    this._elements = value;
    this.updateMiniMap();
  }
  get elements(): NetworkElement[] {
    return this._elements;
  }
  
  @Input() set viewport(value: MiniMapViewport | null) {
    this._viewport = value;
    this.updateViewport();
  }
  get viewport(): MiniMapViewport | null {
    return this._viewport;
  }
  
  @Input() set darkMode(value: boolean) {
    this.isDarkMode = value;
    this.updateTheme();
  }
  
  @Input() set visible(value: boolean) {
    this.isVisible = value;
    this.cdr.markForCheck();
  }
  
  @Input() width = CONSTANTS.MINIMAP.DEFAULT_WIDTH;
  @Input() height = CONSTANTS.MINIMAP.DEFAULT_HEIGHT;
  
  // Variables de estado
  isVisible = true;
  isDarkMode = false;
  
  // Variables internas
  private _elements: NetworkElement[] = [];
  private _viewport: MiniMapViewport | null = null;
  private destroy$ = new Subject<void>();
  private canvasContext: CanvasRenderingContext2D | null = null;
  
  // Servicios
  private logger = inject(LoggerService);
  private cdr = inject(ChangeDetectorRef);
  
  constructor() {}
  
  ngOnInit(): void {
    // Inicialización
  }
  
  ngAfterViewInit(): void {
    this.initializeCanvas();
  }
  
  /**
   * Inicializa el canvas para el minimapa
   */
  private initializeCanvas(): void {
    if (!this.miniMapCanvasEl || !this.miniMapCanvasEl.nativeElement) {
      setTimeout(() => this.initializeCanvas(), 100);
      return;
    }
    
    try {
      // Obtener el elemento canvas
      const canvas = this.miniMapCanvasEl.nativeElement;
      
      // Configurar dimensiones
      canvas.width = this.width;
      canvas.height = this.height;
      
      // Obtener contexto
      this.canvasContext = canvas.getContext('2d');
      
      if (!this.canvasContext) {
        this.logger.error('No se pudo obtener el contexto del canvas');
        return;
      }
      
      // Dibujar elementos
      this.updateMiniMap();
    } catch (error) {
      this.logger.error('Error al inicializar canvas del minimapa:', error);
    }
  }
  
  /**
   * Actualiza el minimapa con los elementos actuales
   */
  private updateMiniMap(): void {
    if (!this.canvasContext || !this._elements.length) return;
    
    try {
      const ctx = this.canvasContext;
      
      // Limpiar canvas
      ctx.clearRect(0, 0, this.width, this.height);
      
      // Calcular límites para centrar y escalar
      const bounds = this.calculateBounds();
      if (!bounds) return;
      
      // Ajustar vista para que todos los elementos sean visibles
      const scaleX = this.width / (bounds.maxX - bounds.minX);
      const scaleY = this.height / (bounds.maxY - bounds.minY);
      const scale = Math.min(scaleX, scaleY) * 0.9;
      
      const offsetX = (this.width - (bounds.maxX - bounds.minX) * scale) / 2;
      const offsetY = (this.height - (bounds.maxY - bounds.minY) * scale) / 2;
      
      // Dibujar elementos
      ctx.fillStyle = this.isDarkMode ? '#4fc3f7' : '#2196f3';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 0.5;
      
      this._elements.forEach(element => {
        if (!element.position?.coordinates) return;
        
        const [x, y] = element.position.coordinates;
        
        // Transformar coordenadas
        const transformedX = (x - bounds.minX) * scale + offsetX;
        const transformedY = (y - bounds.minY) * scale + offsetY;
        
        // Dibujar punto
        ctx.beginPath();
        ctx.arc(transformedX, transformedY, CONSTANTS.MINIMAP.ELEMENT_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });
      
      // Dibujar viewport
      this.updateViewport();
    } catch (error) {
      this.logger.error('Error al actualizar minimapa:', error);
    }
  }
  
  /**
   * Actualiza el rectángulo de viewport
   */
  private updateViewport(): void {
    if (!this.canvasContext || !this._viewport) return;
    
    try {
      const ctx = this.canvasContext;
      const bounds = this.calculateBounds();
      
      if (!bounds) return;
      
      // Ajustar vista para que todos los elementos sean visibles
      const scaleX = this.width / (bounds.maxX - bounds.minX);
      const scaleY = this.height / (bounds.maxY - bounds.minY);
      const scale = Math.min(scaleX, scaleY) * 0.9;
      
      const offsetX = (this.width - (bounds.maxX - bounds.minX) * scale) / 2;
      const offsetY = (this.height - (bounds.maxY - bounds.minY) * scale) / 2;
      
      // Transformar coordenadas del viewport
      const { minX, minY, maxX, maxY } = this._viewport;
      
      const x = (minX - bounds.minX) * scale + offsetX;
      const y = (minY - bounds.minY) * scale + offsetY;
      const width = (maxX - minX) * scale;
      const height = (maxY - minY) * scale;
      
      // Dibujar viewport
      ctx.save();
      
      // Dibujar rectángulo de viewport
      ctx.strokeStyle = CONSTANTS.MINIMAP.VIEWPORT_STROKE;
      ctx.fillStyle = CONSTANTS.MINIMAP.VIEWPORT_FILL;
      ctx.lineWidth = 1;
      
      ctx.fillRect(x, y, width, height);
      ctx.strokeRect(x, y, width, height);
      
      ctx.restore();
    } catch (error) {
      this.logger.error('Error al actualizar viewport:', error);
    }
  }
  
  /**
   * Calcula los límites del mapa
   */
  private calculateBounds(): MiniMapViewport | null {
    if (!this._elements.length) return null;
    
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    
    this._elements.forEach(element => {
      if (!element.position?.coordinates) return;
      
      const [x, y] = element.position.coordinates;
      
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    });
    
    return { minX, minY, maxX, maxY };
  }
  
  /**
   * Actualiza el tema del minimapa
   */
  private updateTheme(): void {
    // Actualizar colores
    this.updateMiniMap();
    this.cdr.markForCheck();
  }
  
  /**
   * Aumenta el zoom del minimapa
   */
  zoomIn(): void {
    // Implementación pendiente
    // Este método aumentaría el zoom del minimapa
  }
  
  /**
   * Disminuye el zoom del minimapa
   */
  zoomOut(): void {
    // Implementación pendiente
    // Este método disminuiría el zoom del minimapa
  }
  
  /**
   * Limpieza al destruir el componente
   */
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
} 